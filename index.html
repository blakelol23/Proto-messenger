<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Firebase Multi-Chat</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
  <style>
    html {
      height: 100%;
    }
    body {
      font-family: 'Poppins', sans-serif;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #1C1E3D 0%, #0A0B1A 100%);
      color: #E0E7FF;
      position: relative;
    }
    /* Starry background */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: radial-gradient(
        circle,
        rgba(255, 255, 255, 0.2) 1px,
        transparent 1px
      );
      background-size: 10px 10px;
      opacity: 0.3;
      animation: twinkle 5s infinite alternate;
    }
    @keyframes twinkle {
      0% { opacity: 0.3; }
      100% { opacity: 0.5; }
    }
    .app {
      max-width: 900px;
      margin: 30px auto;
      height: calc(100vh - 60px);
      display: flex;
      gap: 12px;
      background: rgba(10, 11, 26, 0.6);
      backdrop-filter: blur(8px);
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0, 221, 235, 0.3);
      padding: 12px;
    }
    #chatList {
      width: 28%;
      background: linear-gradient(135deg, rgba(107, 91, 255, 0.2), rgba(161, 0, 242, 0.2));
      border: 1px solid rgba(0, 221, 235, 0.5);
      border-radius: 12px;
      height: 100%;
      overflow-y: auto;
      padding: 12px;
      scrollbar-width: thin;
      scrollbar-color: #00DDEB #1C1E3D;
    }
    #chatList::-webkit-scrollbar {
      width: 8px;
    }
    #chatList::-webkit-scrollbar-track {
      background: #1C1E3D;
    }
    #chatList::-webkit-scrollbar-thumb {
      background: #00DDEB;
      border-radius: 4px;
    }
    #chatArea {
      width: 72%;
      display: flex;
      flex-direction: column;
      height: 100%;
      background: rgba(26, 27, 56, 0.7);
      border-radius: 12px;
      padding: 12px;
      box-shadow: inset 0 0 10px rgba(0, 221, 235, 0.2);
    }
    #chatTitle {
      flex-shrink: 0;
      margin: 0 0 12px 0;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.8em;
      color: #00DDEB;
      text-shadow: 0 0 8px rgba(0, 221, 235, 0.7);
      letter-spacing: 1px;
    }
    #controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-shrink: 0;
    }
    #message {
      flex: 1;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid #00DDEB;
      border-radius: 8px;
      color: #E0E7FF;
      font-size: 1em;
      transition: box-shadow 0.3s ease;
    }
    #message:focus {
      outline: none;
      box-shadow: 0 0 10px #00DDEB;
    }
    #chat {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      border: 1px solid rgba(0, 221, 235, 0.5);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 8px;
      background: rgba(10, 11, 26, 0.5);
      scrollbar-width: thin;
      scrollbar-color: #6B5BFF #1C1E3D;
    }
    #chat::-webkit-scrollbar {
      width: 8px;
    }
    #chat::-webkit-scrollbar-track {
      background: #1C1E3D;
    }
    #chat::-webkit-scrollbar-thumb {
      background: #6B5BFF;
      border-radius: 4px;
    }
    .message {
      margin: 6px 0;
      padding: 10px;
      border-radius: 10px;
      background: linear-gradient(145deg, rgba(107, 91, 255, 0.3), rgba(161, 0, 242, 0.3));
      color: #E0E7FF;
      word-break: break-word;
      max-width: 80%;
      position: relative;
      animation: fadeIn 0.3s ease;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .message strong {
      color: #00DDEB;
      text-shadow: 0 0 5px rgba(0, 221, 235, 0.5);
    }
    button {
      padding: 10px 16px;
      background: linear-gradient(45deg, #6B5BFF, #A100F2);
      border: none;
      border-radius: 8px;
      color: #E0E7FF;
      font-family: 'Orbitron', sans-serif;
      font-size: 1em;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(107, 91, 255, 0.7);
    }
    #startDmBtn {
      min-width: 80px;
      padding: 8px 12px;
      font-size: 0.85em;
      box-shadow: 0 0 8px rgba(107, 91, 255, 0.4);
      height: 36px;
    }
    #startDmBtn:hover {
      box-shadow: 0 0 15px rgba(161, 0, 242, 0.7);
      transform: scale(1.03);
    }
    .chatItem {
      cursor: pointer;
      padding: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 6px;
      border-radius: 8px;
      transition: background 0.2s ease;
      margin-bottom: 4px;
    }
    .chatItem:hover {
      background: rgba(0, 221, 235, 0.2);
    }
    .activeChat {
      background: linear-gradient(45deg, rgba(0, 221, 235, 0.3), rgba(107, 91, 255, 0.3)) !important;
      box-shadow: 0 0 10px rgba(0, 221, 235, 0.5);
    }
    .badge {
      background: #FF3366;
      color: #E0E7FF;
      border-radius: 50%;
      padding: 4px 8px;
      font-size: 0.8em;
      position: absolute;
      top: 8px;
      right: 8px;
    }
    .online-dot, .offline-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      margin: 0;
    }
    .online-dot {
      background: #00FF85;
      box-shadow: 0 0 8px #00FF85;
    }
    .offline-dot {
      background: #66668F;
    }
    .status-span {
      font-size: 0.75em;
      color: #B0B8FF;
      background: rgba(255, 255, 255, 0.05);
      padding: 4px 8px;
      border-radius: 6px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .status-text {
      line-height: 1.2;
    }
    .status-text.online {
      color: #00FF85;
      text-shadow: 0 0 4px rgba(0, 255, 133, 0.5);
    }
    .status-text.offline {
      color: #B0B8FF;
    }
    #typingIndicator {
      font-style: italic;
      color: #B0B8FF;
      height: 20px;
      margin-bottom: 8px;
      flex-shrink: 0;
      text-shadow: 0 0 4px rgba(107, 91, 255, 0.5);
    }
    #dmBox {
      margin: 12px 0;
      display: flex;
      gap: 6px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 6px;
      border: 1px solid rgba(107, 91, 255, 0.3);
      box-shadow: 0 0 8px rgba(107, 91, 255, 0.2);
    }
    #startDmUid {
      flex: 1;
      padding: 6px 8px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(107, 91, 255, 0.1));
      border: 1px solid rgba(107, 91, 255, 0.4);
      border-radius: 4px;
      color: #E0E7FF;
      font-size: 0.85em;
      font-family: 'Poppins', sans-serif;
      line-height: 1.4;
      height: 32px;
      transition: all 0.3s ease;
      box-shadow: inset 0 0 4px rgba(107, 91, 255, 0.1);
    }
    #startDmUid:focus {
      outline: none;
      box-shadow: 0 0 8px rgba(107, 91, 255, 0.6), inset 0 0 4px rgba(107, 91, 255, 0.2);
      border-color: #A100F2;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(107, 91, 255, 0.15));
      transform: scale(1.01);
    }
    #startDmUid::placeholder {
      color: #A0A8D0;
      font-style: italic;
      font-size: 0.85em;
    }
    #startDmUid:not(:placeholder-shown) {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(107, 91, 255, 0.15));
    }
    .loading {
      text-align: center;
      color: #B0B8FF;
      font-style: italic;
      padding: 10px;
    }
    h3 {
      font-family: 'Orbitron', sans-serif;
      color: #00DDEB;
      text-shadow: 0 0 6px rgba(0, 221, 235, 0.6);
      margin: 0 0 12px 0;
    }
  </style>

  <script src="https://www.gstatic.com/firebasejs/10.4.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.4.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.4.0/firebase-auth-compat.js"></script>
</head>
<body>

<div class="app">
<div id="chatList">
  <h3>Your Chats</h3>
  <div id="dmBox">
    <input id="startDmUid" placeholder="Start DM with username..." />
    <button id="startDmBtn">Start DM</button>
  </div>
</div>

<div id="chatArea">
  <h2 id="chatTitle">Chat</h2>
  <div id="chat"></div>
  <div id="typingIndicator"></div>
  <div id="controls">
    <input type="text" id="message" placeholder="Message" />
    <button id="sendBtn">Send</button>
  </div>
</div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const chatBox = document.getElementById("chat");
  const chatListDiv = document.getElementById("chatList");
  const messageInput = document.getElementById("message");
  const sendBtn = document.getElementById("sendBtn");
  const typingIndicator = document.getElementById("typingIndicator");
  const chatTitle = document.getElementById("chatTitle");
  const startDmUid = document.getElementById("startDmUid");
  const startDmBtn = document.getElementById("startDmBtn");

  // Username
  function getDeviceUsername() {
    let username = localStorage.getItem('deviceUsername');
    if (username) return username;
    username = prompt("Enter your device username:", "");
    if (!username || username.trim() === "") {
      username = `User_${Math.random().toString(36).slice(2, 10)}`;
    }
    localStorage.setItem('deviceUsername', username);
    return username;
  }
  let deviceUsername = getDeviceUsername();
  console.log("Using username:", deviceUsername);

  // Firebase config
  const firebaseConfig = {
    apiKey: "AIzaSyCirB765fg0sSsxT6-KRkBSlp2iWk_Pn28",
    authDomain: "test-ff9b2.firebaseapp.com",
    databaseURL: "https://test-ff9b2-default-rtdb.firebaseio.com",
    projectId: "test-ff9b2",
    storageBucket: "test-ff9b2.firebasestorage.app",
    messagingSenderId: "1060238239981",
    appId: "1:1060238239981:web:f12aa5335cd7a48458c4e4",
    measurementId: "G-E5Q5XXMP77"
  };
  const app = firebase.initializeApp(firebaseConfig);
  const db = firebase.database();
  const auth = firebase.auth();

  // State
  let currentUid = null;
  let currentChatId = null;
  let chatListener = null;
  let typingListenerRef = null;
  let typingTimeout = null;
  let onDisconnectRef = null;
  let unreadDMs = {};
  let chatListeners = {};
  let onlineListeners = {};
  let lastSeenCache = {};
  let loadedMessageIds = new Set();
  let messagePageSize = 50;
  let oldestMessageTimestamp = null;
  let newestMessageTimestamp = null;
  let isLoadingMore = false;

  // Update offline statuses periodically
  setInterval(() => {
    document.querySelectorAll('.status-text.offline').forEach(span => {
      const chatItem = span.closest('.chatItem');
      const otherUid = chatItem.dataset.otherUid;
      if (otherUid && lastSeenCache[otherUid]) {
        span.textContent = `Last seen: ${calculateTimeAgo(lastSeenCache[otherUid])}`;
      }
    });
  }, 60000);

  auth.signInAnonymously().then(() => console.log("Signed in anonymously"));

  auth.onAuthStateChanged(user => {
    if (user) {
      currentUid = user.uid;
      console.log("Current UID:", currentUid);
      storeUserProfile().then(() => {
        if ('Notification' in window && Notification.permission === 'default') {
          Notification.requestPermission().then(permission => {
            console.log('Notification permission:', permission);
          });
        }
        setupOnlineStatus();
        joinGlobalChat();
        loadUserChats();
      });
    }
  });

  function setupOnlineStatus() {
    const userRef = db.ref(`/userProfiles/${currentUid}`);
    userRef.child('online').set(true);
    userRef.child('online').onDisconnect().remove();
    userRef.child('lastSeen').onDisconnect().set(firebase.database.ServerValue.TIMESTAMP);
    setInterval(() => {
      userRef.child('lastSeen').set(firebase.database.ServerValue.TIMESTAMP)
        .catch(err => console.warn("Heartbeat failed:", err));
    }, 30000);
  }

  async function storeUserProfile() {
    if (!currentUid || !deviceUsername) return;
    const usernameRef = db.ref(`usernameToUid/${deviceUsername}`);
    const snap = await usernameRef.once('value');
    if (snap.exists() && snap.val() !== currentUid) {
      let newUsername = prompt(`Username "${deviceUsername}" is taken. Choose a new one:`, "");
      if (!newUsername) newUsername = `User_${currentUid.slice(0, 8)}`;
      localStorage.setItem('deviceUsername', newUsername);
      deviceUsername = newUsername;
      return storeUserProfile();
    }
    const updates = {};
    updates[`/userProfiles/${currentUid}/username`] = deviceUsername;
    updates[`/userProfiles/${currentUid}/lastSeen`] = firebase.database.ServerValue.TIMESTAMP;
    updates[`/usernameToUid/${deviceUsername}`] = currentUid;
    await db.ref().update(updates);
    console.log(`Stored profile: ${deviceUsername} -> ${currentUid}`);
  }

  function escapeHtml(s) { return String(s).replace(/[&<>"']/g, c => ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  function calculateTimeAgo(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    if (minutes < 1) return 'just now';
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    return `${days}d ago`;
  }

  function appendMessage(msg, isPrepend = false) {
    const msgEl = document.createElement("div");
    const time = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString() : '';
    msgEl.classList.add("message");
    msgEl.innerHTML = `<strong>${escapeHtml(msg.userName || 'Anonymous')}</strong>: ${escapeHtml(msg.text || '')} <span style="float:right;opacity:0.7;font-size:0.8em">${time}</span>`;
    if (isPrepend) {
      chatBox.insertBefore(msgEl, chatBox.firstChild);
    } else {
      const atBottom = chatBox.scrollHeight - chatBox.scrollTop <= chatBox.clientHeight + 1;
      chatBox.appendChild(msgEl);
      if (atBottom) {
        chatBox.scrollTop = chatBox.scrollHeight;
      }
    }
  }

  function showDesktopNotification(title, body) {
    if (Notification.permission !== 'granted') return;
    const notification = new Notification(escapeHtml(title), {
      body: escapeHtml(body),
      icon: '/favicon.ico',
      tag: 'chat-message'
    });
  }

  function setupUnreadListener(chatId, lastRead) {
    if (chatListeners[chatId]) {
      chatListeners[chatId].off();
      delete chatListeners[chatId];
    }
    const ref = db.ref(`messages/${chatId}`).orderByChild('timestamp').startAt(lastRead + 1);
    ref.on('child_added', snap => {
      const msg = snap.val();
      if (msg.isGlobal || msg.user === currentUid) return;
      unreadDMs[chatId] = (unreadDMs[chatId] || 0) + 1;
      db.ref(`userChats/${currentUid}/${chatId}/unreadCount`)
        .set(unreadDMs[chatId])
        .catch(err => console.warn("Failed to update unreadCount:", err));
      updateChatListBadges();
      updateTitle();
      showDesktopNotification(msg.userName || 'Someone', msg.text || '');
    });
    chatListeners[chatId] = ref;
  }

  function setupAllUnreadListeners() {
    Object.keys(chatListeners).forEach(id => {
      chatListeners[id].off();
      delete chatListeners[id];
    });
    if (!currentUid) return;
    db.ref(`userChats/${currentUid}`).once('value').then(snap => {
      const chats = snap.val() || {};
      Object.keys(chats).forEach(chatId => {
        if (chatId === currentChatId) return;
        const lastRead = chats[chatId].lastReadTimestamp || 0;
        setupUnreadListener(chatId, lastRead);
      });
    });
  }

  function loadMessagePage(chatId, isInitial = false) {
    if (isLoadingMore && !isInitial) return;
    isLoadingMore = true;
    let ref = db.ref(`messages/${chatId}`).orderByChild('timestamp').limitToLast(messagePageSize);
    if (!isInitial && oldestMessageTimestamp !== null) {
      ref = ref.endBefore(oldestMessageTimestamp);
    }
    ref.once('value', snap => {
      const messages = [];
      const newMsgIds = [];
      let newOldest = oldestMessageTimestamp;
      snap.forEach(childSnap => {
        const msg = childSnap.val();
        const msgId = childSnap.key;
        messages.push(msg);
        newMsgIds.push(msgId);
        if (!newOldest || msg.timestamp < newOldest) {
          newOldest = msg.timestamp;
        }
      });
      newMsgIds.forEach(id => loadedMessageIds.add(id));
      const prevScrollHeight = chatBox.scrollHeight;
      const wasAtBottom = chatBox.scrollHeight - chatBox.scrollTop <= chatBox.clientHeight + 1;
      if (isInitial) {
        messages.forEach(msg => appendMessage(msg, false));
      } else {
        messages.reverse().forEach(msg => appendMessage(msg, true));
        chatBox.scrollTop = chatBox.scrollHeight - prevScrollHeight;
      }
      if (messages.length > 0) {
        const batchOldest = messages[0].timestamp;
        const batchNewest = messages[messages.length - 1].timestamp;
        if (isInitial) {
          oldestMessageTimestamp = batchOldest;
          newestMessageTimestamp = batchNewest;
        } else {
          oldestMessageTimestamp = batchOldest;
        }
      }
      if (wasAtBottom && isInitial) {
        chatBox.scrollTop = chatBox.scrollHeight;
      }
      document.querySelectorAll('.loading').forEach(el => el.remove());
      if (!isInitial && messages.length === messagePageSize) {
        const loadMoreEl = document.createElement('div');
        loadMoreEl.classList.add('loading');
        loadMoreEl.textContent = 'Loading older messages...';
        chatBox.insertBefore(loadMoreEl, chatBox.firstChild);
      }
      isLoadingMore = false;
    }).catch(err => {
      console.error('Load error:', err);
      isLoadingMore = false;
    });
  }

  function setupScrollListener() {
    chatBox.onscroll = (e) => {
      if (chatBox.scrollTop === 0 && !isLoadingMore && oldestMessageTimestamp !== null) {
        loadMessagePage(currentChatId, false);
      }
    };
  }

  async function listenMessages(chatId) {
    if (chatListener) chatListener();
    if (typingListenerRef) typingListenerRef.off();
    chatBox.innerHTML = "";
    loadedMessageIds.clear();
    oldestMessageTimestamp = null;
    newestMessageTimestamp = null;
    isLoadingMore = false;
    loadMessagePage(chatId, true);
    setupScrollListener();
    const startTime = newestMessageTimestamp ? newestMessageTimestamp + 1 : 0;
    const newMsgRef = db.ref(`messages/${chatId}`).orderByChild('timestamp').startAt(startTime);
    newMsgRef.on('child_added', snap => {
      const msgId = snap.key;
      if (loadedMessageIds.has(msgId)) return;
      loadedMessageIds.add(msgId);
      const msg = snap.val();
      appendMessage(msg, false);
      newestMessageTimestamp = msg.timestamp;
    });
    chatListener = () => {
      newMsgRef.off();
    };
    setTimeout(() => {
      const currentTime = Date.now();
      if (currentTime > (newestMessageTimestamp || 0)) {
        const missedRef = db.ref(`messages/${chatId}`).orderByChild('timestamp').startAt((newestMessageTimestamp || 0) + 1).limitToLast(5);
        missedRef.once('value', snap => {
          let hasMissed = false;
          snap.forEach(childSnap => {
            const msgId = childSnap.key;
            if (!loadedMessageIds.has(msgId)) {
              loadedMessageIds.add(msgId);
              const msg = childSnap.val();
              appendMessage(msg, false);
              newestMessageTimestamp = msg.timestamp;
              hasMissed = true;
            }
          });
          if (hasMissed) {
            chatBox.scrollTop = chatBox.scrollHeight;
          }
        });
      }
    }, 100);
    listenTyping(chatId);
    setupOnDisconnectForTyping(chatId);
  }

  function setupOnDisconnectForTyping(chatId) {
    if (onDisconnectRef && typeof onDisconnectRef.cancel === 'function') {
      try { onDisconnectRef.onDisconnect().cancel(); } catch(e){ }
    }
    if (currentUid && chatId) {
      const myTypingRef = db.ref(`typing/${chatId}/${currentUid}`);
      try { myTypingRef.onDisconnect().cancel(); } catch(e){ }
      myTypingRef.onDisconnect().remove().catch(()=>{});
      onDisconnectRef = myTypingRef;
    }
  }

  function setTypingFlag(value) {
    if (!currentChatId || !currentUid) return;
    const ref = db.ref(`typing/${currentChatId}/${currentUid}`);
    if (value) {
      try { ref.onDisconnect().remove(); } catch(e){}
      ref.set(true).catch(err => console.warn("typing set error", err));
    } else {
      ref.remove().catch(err => console.warn("typing remove error", err));
      try { ref.onDisconnect().cancel(); } catch(e){}
    }
  }

  function handleTyping() {
    setTypingFlag(true);
    if (typingTimeout) clearTimeout(typingTimeout);
    typingTimeout = setTimeout(() => setTypingFlag(false), 2000);
  }

  function clearTypingFlagImmediate() {
    if (!currentChatId || !currentUid) return;
    const ref = db.ref(`typing/${currentChatId}/${currentUid}`);
    ref.remove().catch(()=>{});
    try { ref.onDisconnect().cancel(); } catch(e){}
    if (typingTimeout) { clearTimeout(typingTimeout); typingTimeout = null; }
  }

  messageInput.addEventListener("input", handleTyping);

  function listenTyping(chatId) {
    const ref = db.ref(`typing/${chatId}`);
    typingListenerRef = ref;
    ref.on('value', async snap => {
      const data = snap.val() || {};
      const typingUids = Object.keys(data).filter(uid => uid !== currentUid && data[uid]);
      if (typingUids.length === 0) {
        typingIndicator.textContent = "";
        return;
      }
      const names = [];
      for (const uid of typingUids) {
        let name = sessionStorage.getItem("uname_" + uid);
        if (!name) {
          const nameSnap = await db.ref(`userProfiles/${uid}/username`).once('value');
          name = nameSnap.val() || "Unknown";
          sessionStorage.setItem("uname_" + uid, name);
        }
        names.push(name);
      }
      if (names.length === 1) typingIndicator.textContent = `${names[0]} is typing...`;
      else if (names.length === 2) typingIndicator.textContent = `${names[0]} and ${names[1]} are typing...`;
      else typingIndicator.textContent = `${names.slice(0,2).join(', ')} and ${names.length-2} others are typing...`;
    });
  }

  async function sendMessage() {
    if (!currentChatId) return alert("Select a chat first!");
    const text = messageInput.value.trim();
    if (!text) return;
    const userName = deviceUsername;
    const clientTimestamp = Date.now();
    const messageRef = db.ref(`messages/${currentChatId}`).push();
    const messageId = messageRef.key;
    const messageObj = { 
      user: currentUid, 
      userName, 
      text, 
      timestamp: firebase.database.ServerValue.TIMESTAMP,
      clientTimestamp,
      isGlobal: currentChatId === 'global_chat' 
    };
    loadedMessageIds.add(messageId);
    appendMessage({ ...messageObj, timestamp: clientTimestamp }, false);
    const updates = {};
    updates[`/messages/${currentChatId}/${messageId}`] = messageObj;
    updates[`/chats/${currentChatId}/lastMessage`] = { text, sender: currentUid, timestamp: firebase.database.ServerValue.TIMESTAMP };
    await db.ref().update(updates);
    clearTypingFlagImmediate();
    messageInput.value = "";
  }
  sendBtn.addEventListener("click", sendMessage);
  messageInput.addEventListener("keyup", e => { if (e.key === "Enter") sendMessage(); });

  async function joinGlobalChat() {
    const chatId = "global_chat";
    const chatRef = db.ref(`chats/${chatId}`);
    const snap = await chatRef.once('value');
    if (!snap.exists()) {
      await chatRef.set({ title: "Global Chat", isGroup: true, participants: {}, createdAt: Date.now() });
    }
    const updates = {};
    updates[`/chats/${chatId}/participants/${currentUid}`] = true;
    updates[`/userChats/${currentUid}/${chatId}`] = { chatId, lastReadTimestamp: Date.now(), unreadCount: 0, nickname: "Me" };
    await db.ref().update(updates);
    currentChatId = chatId;
    listenMessages(chatId);
    setupAllUnreadListeners();
  }

  function makeDMId(uidA, uidB) { return [uidA, uidB].sort().join('_'); }

  async function createDMByUsername(username) {
    if (!currentUid) return alert("Not signed in yet");
    const uidSnap = await db.ref(`usernameToUid/${username}`).once('value');
    const otherUid = uidSnap.val();
    if (!otherUid) return alert(`User "${username}" not found.`);
    if (otherUid === currentUid) return alert("Cannot DM yourself!");
    const chatId = makeDMId(currentUid, otherUid);
    const chatRef = db.ref(`chats/${chatId}`);
    const chatSnap = await chatRef.once('value');
    const updates = {};
    if (!chatSnap.exists()) {
      const chatData = { isGroup: false, participants: { [currentUid]: true, [otherUid]: true }, createdAt: Date.now() };
      updates[`/chats/${chatId}`] = chatData;
    }
    updates[`/userChats/${currentUid}/${chatId}`] = { chatId, lastReadTimestamp: Date.now(), unreadCount: 0 };
    if (!chatSnap.exists()) {
      updates[`/userChats/${otherUid}/${chatId}`] = { chatId, lastReadTimestamp: 0, unreadCount: 0 };
    }
    await db.ref().update(updates);
    currentChatId = chatId;
    unreadDMs[chatId] = 0;
    updateChatListBadges();
    updateTitle();
    listenMessages(chatId);
    setupAllUnreadListeners();
  }

  startDmBtn.addEventListener('click', () => {
    const username = startDmUid.value.trim();
    if (!username) return alert("Enter username");
    createDMByUsername(username).catch(console.error);
    startDmUid.value = '';
  });
  startDmUid.addEventListener('keyup', e => {
    if (e.key === "Enter") {
      const username = startDmUid.value.trim();
      if (!username) return alert("Enter username");
      createDMByUsername(username).catch(console.error);
      startDmUid.value = '';
    }
  });

  function updateChatListBadges() {
    document.querySelectorAll('.chatItem').forEach(div => {
      const chatId = div.dataset.chatId;
      const badgeSpan = div.querySelector('.badge');
      if (unreadDMs[chatId]) {
        if (!badgeSpan) {
          const span = document.createElement('span');
          span.classList.add('badge');
          span.textContent = unreadDMs[chatId];
          div.appendChild(span);
        } else {
          badgeSpan.textContent = unreadDMs[chatId];
        }
      } else {
        if (badgeSpan) badgeSpan.remove();
      }
    });
  }

  function updateTitle() {
    const totalUnread = Object.values(unreadDMs).reduce((a, b) => a + b, 0);
    document.title = totalUnread > 0 ? `(${totalUnread}) Firebase Multi-Chat` : "Firebase Multi-Chat";
  }

  function loadUserChats() {
    if (!currentUid) return;
    db.ref(`userChats/${currentUid}`).on('value', async snap => {
      Object.keys(onlineListeners).forEach(uid => {
        if (onlineListeners[uid]) onlineListeners[uid].off();
      });
      onlineListeners = {};
      const chats = snap.val() || {};
      unreadDMs = {};
      for (let chatId in chats) {
        unreadDMs[chatId] = chats[chatId].unreadCount || 0;
      }
      const existingChatItems = new Map();
      document.querySelectorAll('.chatItem').forEach(div => {
        existingChatItems.set(div.dataset.chatId, div);
      });
      const dmBox = document.getElementById('dmBox');

      // Handle Global Chat separately (above search bar)
      let globalDiv = null;
      for (let chatId in chats) {
        if (chatId === 'global_chat') {
          let div = existingChatItems.get(chatId);
          if (!div) {
            div = document.createElement('div');
            div.classList.add('chatItem');
            div.dataset.chatId = chatId;
          } else {
            existingChatItems.delete(chatId);
          }
          const chatMetaSnap = await db.ref(`chats/${chatId}`).once('value');
          const chatMeta = chatMetaSnap.val() || {};
          let displayText = '';
          if (chatMeta.isGroup) {
            displayText = chatMeta.title || chatId;
          } else {
            displayText = chatId;
          }
          if (div.innerHTML !== displayText) {
            div.innerHTML = displayText;
          }
          if (chatId === currentChatId) {
            div.classList.add('activeChat');
          } else {
            div.classList.remove('activeChat');
          }
          div.onclick = () => {
            currentChatId = chatId;
            unreadDMs[chatId] = 0;
            db.ref(`userChats/${currentUid}/${chatId}/unreadCount`).set(0);
            updateChatListBadges();
            updateTitle();
            document.querySelectorAll('.chatItem').forEach(el => el.classList.remove('activeChat'));
            div.classList.add('activeChat');
            const updates = {};
            updates[`/userChats/${currentUid}/${chatId}/lastReadTimestamp`] = Date.now();
            db.ref().update(updates);
            listenMessages(chatId);
            setupAllUnreadListeners();
          };
          globalDiv = div;
          break;
        }
      }
      if (globalDiv && !globalDiv.parentNode) {
        chatListDiv.insertBefore(globalDiv, dmBox);
      }

      // Handle other chats (below search bar)
      const fragment = document.createDocumentFragment();
      for (let chatId in chats) {
        if (chatId === 'global_chat') continue;
        let div = existingChatItems.get(chatId);
        if (!div) {
          div = document.createElement('div');
          div.classList.add('chatItem');
          div.dataset.chatId = chatId;
        } else {
          existingChatItems.delete(chatId);
        }
        const chatMetaSnap = await db.ref(`chats/${chatId}`).once('value');
        const chatMeta = chatMetaSnap.val() || {};
        let displayText = '';
        let initialStatusHtml = '';
        if (chatMeta.isGroup) {
          displayText = chatMeta.title || chatId;
        } else {
          const otherUid = chatMeta.participants ? Object.keys(chatMeta.participants).filter(uid => uid !== currentUid)[0] : '';
          if (otherUid) {
            div.dataset.otherUid = otherUid;
            const profileSnap = await db.ref(`userProfiles/${otherUid}/username`).once('value');
            const otherUsername = profileSnap.val() || otherUid;
            const onlineSnap = await db.ref(`userProfiles/${otherUid}/online`).once('value');
            const isOnline = onlineSnap.val() === true;
            let statusDot, statusTextClass, statusText;
            if (isOnline) {
              statusDot = '<span class="online-dot"></span>';
              statusTextClass = 'status-text online';
              statusText = 'Online';
            } else {
              statusDot = '<span class="offline-dot"></span>';
              statusTextClass = 'status-text offline';
              const lastSeenSnap = await db.ref(`userProfiles/${otherUid}/lastSeen`).once('value');
              const lastSeen = lastSeenSnap.val();
              lastSeenCache[otherUid] = lastSeen;
              statusText = lastSeen ? `Last seen: ${calculateTimeAgo(lastSeen)}` : 'Last seen: unknown';
            }
            initialStatusHtml = `${statusDot}<span class="${statusTextClass}" aria-live="polite">${statusText}</span>`;
            displayText = `DM: ${otherUsername}`;
            if (!onlineListeners[otherUid]) {
              const onlineRef = db.ref(`userProfiles/${otherUid}/online`);
              onlineRef.on('value', async (statusSnap) => {
                const currentIsOnline = statusSnap.val() === true;
                let newStatusHtml = '';
                let newStatusDot, newStatusTextClass, newStatusText;
                if (currentIsOnline) {
                  newStatusDot = '<span class="online-dot"></span>';
                  newStatusTextClass = 'status-text online';
                  newStatusText = 'Online';
                } else {
                  newStatusDot = '<span class="offline-dot"></span>';
                  newStatusTextClass = 'status-text offline';
                  const lastSeenSnap = await db.ref(`userProfiles/${otherUid}/lastSeen`).once('value');
                  const lastSeen = lastSeenSnap.val();
                  lastSeenCache[otherUid] = lastSeen;
                  newStatusText = lastSeen ? `Last seen: ${calculateTimeAgo(lastSeen)}` : 'Last seen: unknown';
                }
                newStatusHtml = `${newStatusDot}<span class="${newStatusTextClass}" aria-live="polite">${newStatusText}</span>`;
                const currentDiv = document.querySelector(`[data-otherUid="${otherUid}"]`);
                if (currentDiv) {
                  const statusSpan = currentDiv.querySelector('.status-span');
                  if (statusSpan) {
                    statusSpan.innerHTML = newStatusHtml;
                  }
                }
              });
              onlineListeners[otherUid] = onlineRef;
            }
          } else {
            displayText = chatId;
          }
        }
        if (div.innerHTML !== displayText || !div.querySelector('.status-span')) {
          div.innerHTML = displayText;
          if (initialStatusHtml) {
            const statusSpan = document.createElement('span');
            statusSpan.className = 'status-span';
            statusSpan.innerHTML = initialStatusHtml;
            div.appendChild(statusSpan);
          }
        }
        if (chatId === currentChatId) {
          div.classList.add('activeChat');
        } else {
          div.classList.remove('activeChat');
        }
        div.onclick = () => {
          currentChatId = chatId;
          unreadDMs[chatId] = 0;
          db.ref(`userChats/${currentUid}/${chatId}/unreadCount`).set(0);
          updateChatListBadges();
          updateTitle();
          document.querySelectorAll('.chatItem').forEach(el => el.classList.remove('activeChat'));
          div.classList.add('activeChat');
          const updates = {};
          updates[`/userChats/${currentUid}/${chatId}/lastReadTimestamp`] = Date.now();
          db.ref().update(updates);
          listenMessages(chatId);
          setupAllUnreadListeners();
        };
        if (!div.parentNode) {
          fragment.appendChild(div);
        }
      }

      // Insert non-global chats after dmBox
      const afterDmBox = dmBox.nextSibling;
      if (afterDmBox) {
        chatListDiv.insertBefore(fragment, afterDmBox);
      } else {
        chatListDiv.appendChild(fragment);
      }

      // Remove remaining existing items
      existingChatItems.forEach(div => div.remove());

      updateChatListBadges();
      setupAllUnreadListeners();
    });
  }

  window.addEventListener('beforeunload', () => {
    if (currentChatId && currentUid) {
      try { db.ref(`typing/${currentChatId}/${currentUid}`).remove(); } catch(e) {}
    }
    Object.keys(chatListeners).forEach(id => {
      chatListeners[id].off();
    });
    Object.keys(onlineListeners).forEach(uid => {
      if (onlineListeners[uid]) onlineListeners[uid].off();
    });
  });
});
</script>

</body>
</html>
