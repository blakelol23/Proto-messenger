<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Firebase Multi-Chat</title>
  <style>
    html {
      height: 100%;
    }
    body { 
      font-family: Arial, sans-serif; 
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    .app {
      max-width: 900px;
      margin: 30px auto;
      height: calc(100vh - 60px);
      display: flex;
      gap: 10px;
    }
    #chatList { 
      width: 28%; 
      border: 1px solid #000; 
      height: 100%;
      overflow-y: auto; 
      padding: 5px; 
    }
    #chatArea { 
      width: 72%; 
      display: flex; 
      flex-direction: column; 
      height: 100%;
    }
    #chatTitle {
      flex-shrink: 0;
      margin: 0 0 10px 0;
    }
    #controls { 
      display:flex; 
      gap:6px; 
      align-items:center; 
      flex-shrink: 0;
    }
    #message { 
      flex:1; 
      padding:6px; 
    }
    #chat {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      border: 1px solid #000;
      padding: 10px;
      margin-bottom: 6px;
    }
    .message {
      margin: 2px 0;
      padding: 6px;
      border-radius: 6px;
      background: #f0f0f0;
      word-break: break-word;
    }
    button { padding:8px 12px; }
    .message strong { color: #007BFF; }
    .chatItem { cursor: pointer; padding: 6px; border-bottom: 1px solid #eee; position: relative; }
    .chatItem:hover { background: #e9f4ff; }
    .activeChat { background: #d0f8ff !important; }
    .badge { background:red; color:white; border-radius:50%; padding:2px 6px; font-size:0.8em; position:absolute; top:4px; right:6px; }
    .online-dot { display: inline-block; width: 8px; height: 8px; background: #4CAF50; border-radius: 50%; margin-left: 4px; }
    .offline-dot { display: inline-block; width: 8px; height: 8px; background: #ccc; border-radius: 50%; margin-left: 4px; }
    .status-text { font-size: 0.8em; margin-left: 4px; }
    .status-text.online { color: #4CAF50; }
    .status-text.offline { color: #666; }
    #typingIndicator { 
      font-style: italic; 
      color: gray; 
      height:20px; 
      margin-bottom:6px; 
      flex-shrink: 0;
    }
    #dmBox { margin-top:8px; display:flex; gap:6px; }
    #startDmUid { flex:1; padding:6px; }
    .loading { text-align: center; color: gray; font-style: italic; }
  </style>

  <script src="https://www.gstatic.com/firebasejs/10.4.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.4.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.4.0/firebase-auth-compat.js"></script>
</head>
<body>

<div class="app">
<div id="chatList">
  <h3>Your Chats</h3>
  <div id="dmBox">
    <input id="startDmUid" placeholder="Start DM with username..." />
    <button id="startDmBtn">Start DM</button>
  </div>
</div>

<div id="chatArea">
  <h2 id="chatTitle">Chat</h2>
  <div id="chat"></div>
  <div id="typingIndicator"></div>
  <div id="controls">
    <input type="text" id="message" placeholder="Message" />
    <button id="sendBtn">Send</button>
  </div>
</div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const chatBox = document.getElementById("chat");
  const chatListDiv = document.getElementById("chatList");
  const messageInput = document.getElementById("message");
  const sendBtn = document.getElementById("sendBtn");
  const typingIndicator = document.getElementById("typingIndicator");
  const chatTitle = document.getElementById("chatTitle");
  const startDmUid = document.getElementById("startDmUid");
  const startDmBtn = document.getElementById("startDmBtn");

  // Username
  function getDeviceUsername() {
    let username = localStorage.getItem('deviceUsername');
    if (username) return username;
    username = prompt("Enter your device username:", "") || "User";
    localStorage.setItem('deviceUsername', username);
    return username;
  }
  const deviceUsername = getDeviceUsername();
  console.log("Using username:", deviceUsername);

  // Firebase config
  const firebaseConfig = {
    apiKey: "AIzaSyCirB765fg0sSsxT6-KRkBSlp2iWk_Pn28",
    authDomain: "test-ff9b2.firebaseapp.com",
    databaseURL: "https://test-ff9b2-default-rtdb.firebaseio.com",
    projectId: "test-ff9b2",
    storageBucket: "test-ff9b2.firebasestorage.app",
    messagingSenderId: "1060238239981",
    appId: "1:1060238239981:web:f12aa5335cd7a48458c4e4",
    measurementId: "G-E5Q5XXMP77"
  };
  const app = firebase.initializeApp(firebaseConfig);
  const db = firebase.database();
  const auth = firebase.auth();

  // State
  let currentUid = null;
  let currentChatId = null;
  let chatListener = null;
  let typingListenerRef = null;
  let typingTimeout = null;
  let onDisconnectRef = null;
  let unreadDMs = {};
  let chatListeners = {}; // For unread listeners per background chat
  let onlineListeners = {}; // For online status listeners per user
  let loadedMessageIds = new Set();
  let messagePageSize = 50;
  let oldestMessageTimestamp = null;
  let newestMessageTimestamp = null;
  let isLoadingMore = false;

  auth.signInAnonymously().then(()=>console.log("Signed in anonymously"));

  auth.onAuthStateChanged(user => {
    if (user) {
      currentUid = user.uid;
      console.log("Current UID:", currentUid);
      storeUserProfile().then(() => {
        // Request notification permission
        if ('Notification' in window && Notification.permission === 'default') {
          Notification.requestPermission().then(permission => {
            console.log('Notification permission:', permission);
          });
        }
        setupOnlineStatus();
        joinGlobalChat();
        loadUserChats();
      });
    }
  });

  // Online status
  function setupOnlineStatus() {
    const userRef = db.ref(`/userProfiles/${currentUid}`);
    userRef.child('online').set(true);
    userRef.child('online').onDisconnect().remove();
    userRef.child('lastSeen').onDisconnect().set(firebase.database.ServerValue.TIMESTAMP);
  }

  async function storeUserProfile() {
    if (!currentUid || !deviceUsername) return;
    const updates = {};
    updates[`/userProfiles/${currentUid}/username`] = deviceUsername;
    updates[`/userProfiles/${currentUid}/lastSeen`] = firebase.database.ServerValue.TIMESTAMP;
    updates[`/usernameToUid/${deviceUsername}`] = currentUid;
    await db.ref().update(updates);
    console.log(`Stored profile: ${deviceUsername} -> ${currentUid}`);
  }

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  function calculateTimeAgo(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (minutes < 1) return 'just now';
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    return `${days}d ago`;
  }

  function appendMessage(msg, isPrepend = false) {
    const msgEl = document.createElement("div");
    const time = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString() : '';
    msgEl.classList.add("message");
    msgEl.innerHTML = `<strong>${escapeHtml(msg.userName || 'Anonymous')}</strong>: ${escapeHtml(msg.text || '')} <span style="float:right;opacity:0.7;font-size:0.8em">${time}</span>`;

    if (isPrepend) {
      chatBox.insertBefore(msgEl, chatBox.firstChild);
    } else {
      const atBottom = chatBox.scrollHeight - chatBox.scrollTop <= chatBox.clientHeight + 1;
      chatBox.appendChild(msgEl);
      if (atBottom) {
        chatBox.scrollTop = chatBox.scrollHeight;
      }
    }
  }

  // Desktop notification
  function showDesktopNotification(title, body) {
    if (Notification.permission !== 'granted') return;
    const notification = new Notification(escapeHtml(title), {
      body: escapeHtml(body),
      icon: '/favicon.ico', // Replace with your icon if available
      tag: 'chat-message'
    });
  }

  // Unread listener setup for a single background chat
  function setupUnreadListener(chatId, lastRead) {
    if (chatListeners[chatId]) {
      chatListeners[chatId].off();
      delete chatListeners[chatId];
    }
    const ref = db.ref(`messages/${chatId}`).orderByChild('timestamp').startAt(lastRead + 1);
    ref.on('child_added', snap => {
      const msg = snap.val();
      if (msg.isGlobal || msg.user === currentUid) return; // Skip global and own messages
      unreadDMs[chatId] = (unreadDMs[chatId] || 0) + 1;
      updateChatListBadges();
      updateTitle();
      showDesktopNotification(msg.userName || 'Someone', msg.text || '');
    });
    chatListeners[chatId] = ref;
  }

  // Setup listeners for all non-current chats
  function setupAllUnreadListeners() {
    // Clean up existing
    Object.keys(chatListeners).forEach(id => {
      chatListeners[id].off();
      delete chatListeners[id];
    });
    if (!currentUid) return;
    db.ref(`userChats/${currentUid}`).once('value').then(snap => {
      const chats = snap.val() || {};
      Object.keys(chats).forEach(chatId => {
        if (chatId === currentChatId) return;
        const lastRead = chats[chatId].lastReadTimestamp || 0;
        setupUnreadListener(chatId, lastRead);
      });
    });
  }

  // Infinite scroll
  function loadMessagePage(chatId, isInitial = false) {
    if (isLoadingMore && !isInitial) return;
    isLoadingMore = true;

    let ref = db.ref(`messages/${chatId}`).orderByChild('timestamp').limitToLast(messagePageSize);
    if (!isInitial && oldestMessageTimestamp !== null) {
      ref = ref.endBefore(oldestMessageTimestamp);
    }

    ref.once('value', snap => {
      const messages = [];
      const newMsgIds = [];
      let newOldest = oldestMessageTimestamp;
      snap.forEach(childSnap => {
        const msg = childSnap.val();
        const msgId = childSnap.key;
        messages.push(msg);
        newMsgIds.push(msgId);
        if (!newOldest || msg.timestamp < newOldest) {
          newOldest = msg.timestamp;
        }
      });

      // Add to loaded set
      newMsgIds.forEach(id => loadedMessageIds.add(id));

      const prevScrollHeight = chatBox.scrollHeight;
      const wasAtBottom = chatBox.scrollHeight - chatBox.scrollTop <= chatBox.clientHeight + 1;

      if (isInitial) {
        messages.forEach(msg => appendMessage(msg, false));
      } else {
        messages.reverse().forEach(msg => appendMessage(msg, true));
        chatBox.scrollTop = chatBox.scrollHeight - prevScrollHeight;
      }

      if (messages.length > 0) {
        const batchOldest = messages[0].timestamp;
        const batchNewest = messages[messages.length - 1].timestamp;
        if (isInitial) {
          oldestMessageTimestamp = batchOldest;
          newestMessageTimestamp = batchNewest;
        } else {
          oldestMessageTimestamp = batchOldest;
        }
      }

      if (wasAtBottom && isInitial) {
        chatBox.scrollTop = chatBox.scrollHeight;
      }

      // Show/hide loading
      const loadingEl = document.querySelector('.loading');
      if (loadingEl) loadingEl.remove();
      if (!isInitial && messages.length === messagePageSize) {
        const loadMoreEl = document.createElement('div');
        loadMoreEl.classList.add('loading');
        loadMoreEl.textContent = 'Loading older messages...';
        chatBox.insertBefore(loadMoreEl, chatBox.firstChild);
      }

      isLoadingMore = false;
    }).catch(err => {
      console.error('Load error:', err);
      isLoadingMore = false;
    });
  }

  function setupScrollListener() {
    chatBox.onscroll = (e) => {
      if (chatBox.scrollTop === 0 && !isLoadingMore && oldestMessageTimestamp !== null) {
        loadMessagePage(currentChatId, false);
      }
    };
  }

  // --- Messages & Typing ---
  async function listenMessages(chatId) {
    if (chatListener) chatListener();
    if (typingListenerRef) typingListenerRef.off();

    chatBox.innerHTML = "";
    loadedMessageIds.clear();
    oldestMessageTimestamp = null;
    newestMessageTimestamp = null;
    isLoadingMore = false;

    loadMessagePage(chatId, true);
    setupScrollListener();

    // Listen for new messages (only future ones)
    const startTime = newestMessageTimestamp ? newestMessageTimestamp + 1 : 0;
    const newMsgRef = db.ref(`messages/${chatId}`).orderByChild('timestamp').startAt(startTime);
    newMsgRef.on('child_added', snap => {
      const msgId = snap.key;
      if (loadedMessageIds.has(msgId)) return;
      loadedMessageIds.add(msgId);
      const msg = snap.val();
      appendMessage(msg, false);
      newestMessageTimestamp = msg.timestamp;
    });
    chatListener = () => {
      newMsgRef.off();
    };

    // Check for missed messages during race (small window)
    setTimeout(() => {
      const currentTime = Date.now();
      if (currentTime > (newestMessageTimestamp || 0)) {
        const missedRef = db.ref(`messages/${chatId}`).orderByChild('timestamp').startAt((newestMessageTimestamp || 0) + 1).limitToLast(5);
        missedRef.once('value', snap => {
          let hasMissed = false;
          snap.forEach(childSnap => {
            const msgId = childSnap.key;
            if (!loadedMessageIds.has(msgId)) {
              loadedMessageIds.add(msgId);
              const msg = childSnap.val();
              appendMessage(msg, false);
              newestMessageTimestamp = msg.timestamp;
              hasMissed = true;
            }
          });
          if (hasMissed) {
            chatBox.scrollTop = chatBox.scrollHeight;
          }
        });
      }
    }, 100);

    listenTyping(chatId);
    setupOnDisconnectForTyping(chatId);
  }

  function setupOnDisconnectForTyping(chatId) {
    if (onDisconnectRef && typeof onDisconnectRef.cancel === 'function') {
      try { onDisconnectRef.onDisconnect().cancel(); } catch(e){ }
    }
    if (currentUid && chatId) {
      const myTypingRef = db.ref(`typing/${chatId}/${currentUid}`);
      try { myTypingRef.onDisconnect().cancel(); } catch(e){ }
      myTypingRef.onDisconnect().remove().catch(()=>{});
      onDisconnectRef = myTypingRef;
    }
  }

  function setTypingFlag(value) {
    if (!currentChatId || !currentUid) return;
    const ref = db.ref(`typing/${currentChatId}/${currentUid}`);
    if (value) {
      try { ref.onDisconnect().remove(); } catch(e){}
      ref.set(true).catch(err => console.warn("typing set error", err));
    } else {
      ref.remove().catch(err => console.warn("typing remove error", err));
      try { ref.onDisconnect().cancel(); } catch(e){}
    }
  }

  function handleTyping() {
    setTypingFlag(true);
    if (typingTimeout) clearTimeout(typingTimeout);
    typingTimeout = setTimeout(()=>setTypingFlag(false), 2000);
  }
  function clearTypingFlagImmediate() {
    if (!currentChatId || !currentUid) return;
    const ref = db.ref(`typing/${currentChatId}/${currentUid}`);
    ref.remove().catch(()=>{});
    try { ref.onDisconnect().cancel(); } catch(e){}
    if (typingTimeout) { clearTimeout(typingTimeout); typingTimeout = null; }
  }

  messageInput.addEventListener("input", handleTyping);

  function listenTyping(chatId) {
    const ref = db.ref(`typing/${chatId}`);
    typingListenerRef = ref;
    ref.on('value', async snap => {
      const data = snap.val() || {};
      const typingUids = Object.keys(data).filter(uid => uid !== currentUid && data[uid]);
      if (typingUids.length === 0) {
        typingIndicator.textContent = "";
        return;
      }
      const names = [];
      for (const uid of typingUids) {
        let name = sessionStorage.getItem("uname_" + uid);
        if (!name) {
          const nameSnap = await db.ref(`userProfiles/${uid}/username`).once('value');
          name = nameSnap.val() || "Unknown";
          sessionStorage.setItem("uname_" + uid, name);
        }
        names.push(name);
      }

      if (names.length === 1) typingIndicator.textContent = `${names[0]} is typing...`;
      else if (names.length === 2) typingIndicator.textContent = `${names[0]} and ${names[1]} are typing...`;
      else typingIndicator.textContent = `${names.slice(0,2).join(', ')} and ${names.length-2} others are typing...`;
    });
  }

  // --- Send message ---
  async function sendMessage() {
    if (!currentChatId) return alert("Select a chat first!");
    const text = messageInput.value.trim();
    if (!text) return;
    const userName = deviceUsername;
    const clientTimestamp = Date.now();
    const messageRef = db.ref(`messages/${currentChatId}`).push();
    const messageId = messageRef.key;
    const messageObj = { 
      user: currentUid, 
      userName, 
      text, 
      timestamp: firebase.database.ServerValue.TIMESTAMP,
      clientTimestamp,
      isGlobal: currentChatId==='global_chat' 
    };

    // Optimistic append with client time for display
    const optimisticMsg = { ...messageObj, timestamp: clientTimestamp };
    loadedMessageIds.add(messageId);
    appendMessage(optimisticMsg, false);

    const updates = {};
    updates[`/messages/${currentChatId}/${messageId}`] = messageObj;
    updates[`/chats/${currentChatId}/lastMessage`] = { text, sender: currentUid, timestamp: firebase.database.ServerValue.TIMESTAMP };

    await db.ref().update(updates);
    clearTypingFlagImmediate();
    messageInput.value = "";
  }
  sendBtn.addEventListener("click", sendMessage);
  messageInput.addEventListener("keyup", e=>{ if(e.key==="Enter") sendMessage(); });

  // --- Global Chat ---
  async function joinGlobalChat() {
    const chatId = "global_chat";
    const chatRef = db.ref(`chats/${chatId}`);
    const snap = await chatRef.once('value');
    if (!snap.exists()) {
      await chatRef.set({ title:"Global Chat", isGroup:true, participants:{}, createdAt:Date.now() });
    }
    const updates = {};
    updates[`/chats/${chatId}/participants/${currentUid}`] = true;
    updates[`/userChats/${currentUid}/${chatId}`] = { chatId, lastReadTimestamp: Date.now(), unreadCount:0, nickname:"Me" };
    await db.ref().update(updates);
    currentChatId = chatId;
    listenMessages(chatId);
    setupAllUnreadListeners(); // Setup after initial load
  }

  // --- DM Helpers ---
  function makeDMId(uidA, uidB){ return [uidA,uidB].sort().join('_'); }

  async function createDMByUsername(username){
    if(!currentUid) return alert("Not signed in yet");
    const uidSnap = await db.ref(`usernameToUid/${username}`).once('value');
    const otherUid = uidSnap.val();
    if(!otherUid) return alert(`User "${username}" not found.`);
    if(otherUid===currentUid) return alert("Cannot DM yourself!");
    const chatId = makeDMId(currentUid, otherUid);
    const chatRef = db.ref(`chats/${chatId}`);
    const chatSnap = await chatRef.once('value');
    const updates = {};
    if(!chatSnap.exists()){
      const chatData = { isGroup:false, participants:{[currentUid]:true,[otherUid]:true}, createdAt:Date.now() };
      updates[`/chats/${chatId}`] = chatData;
    }
    // Always add to current user's userChats, even if chat exists
    updates[`/userChats/${currentUid}/${chatId}`] = { chatId, lastReadTimestamp: Date.now(), unreadCount:0 };
    // Add to other if chat new
    if (!chatSnap.exists()) {
      updates[`/userChats/${otherUid}/${chatId}`] = { chatId, lastReadTimestamp: 0, unreadCount:0 };
    }
    await db.ref().update(updates);
    currentChatId = chatId;
    unreadDMs[chatId] = 0;
    updateChatListBadges();
    updateTitle();
    listenMessages(chatId);
    setupAllUnreadListeners(); // Re-setup after switch
  }

  startDmBtn.addEventListener('click', ()=>{
    const username = startDmUid.value.trim();
    if(!username) return alert("Enter username");
    createDMByUsername(username).catch(console.error);
    startDmUid.value = '';
  });
  startDmUid.addEventListener('keyup', e=>{
    if(e.key==="Enter"){
      const username = startDmUid.value.trim();
      if(!username) return alert("Enter username");
      createDMByUsername(username).catch(console.error);
      startDmUid.value='';
    }
  });

  // --- Load User Chats & badges ---
  function updateChatListBadges() {
    document.querySelectorAll('.chatItem').forEach(div=>{
      const chatId = div.dataset.chatId;
      const badgeSpan = div.querySelector('.badge');
      if(unreadDMs[chatId]) {
        if(!badgeSpan){
          const span = document.createElement('span');
          span.classList.add('badge');
          span.textContent = unreadDMs[chatId];
          div.appendChild(span);
        } else { badgeSpan.textContent = unreadDMs[chatId]; }
      } else {
        if(badgeSpan) badgeSpan.remove();
      }
    });
  }

  function updateTitle(){
    const totalUnread = Object.values(unreadDMs).reduce((a,b)=>a+b,0);
    document.title = totalUnread>0 ? `(${totalUnread}) Firebase Multi-Chat` : "Firebase Multi-Chat";
  }

  function loadUserChats(){
    if(!currentUid) return;
    db.ref(`userChats/${currentUid}`).on('value', async snap=>{
      // Clean up old listeners
      Object.keys(onlineListeners).forEach(uid => {
        if (onlineListeners[uid]) onlineListeners[uid].off();
      });
      onlineListeners = {};

      const dmBox = document.getElementById('dmBox');
      chatListDiv.innerHTML='<h3>Your Chats</h3>';
      chatListDiv.appendChild(dmBox);
      const chats = snap.val()||{};

      for(let chatId in chats){
        const chatMetaSnap = await db.ref(`chats/${chatId}`).once('value');
        const chatMeta = chatMetaSnap.val()||{};
        const div = document.createElement('div');
        div.classList.add('chatItem');
        div.dataset.chatId = chatId;

        let displayText = '';
        let initialStatusHtml = '';

        if(chatMeta.isGroup) {
          displayText = chatMeta.title || chatId;
        } else {
          const otherUid = chatMeta.participants ? Object.keys(chatMeta.participants).filter(uid=>uid!==currentUid)[0]:'';
          if(otherUid){
            div.dataset.otherUid = otherUid;
            const profileSnap = await db.ref(`userProfiles/${otherUid}/username`).once('value');
            const otherUsername = profileSnap.val()||otherUid;

            // Initial status
            const onlineSnap = await db.ref(`userProfiles/${otherUid}/online`).once('value');
            const isOnline = onlineSnap.val() === true;
            let statusDot, statusTextClass, statusText;
            if (isOnline) {
              statusDot = '<span class="online-dot"></span>';
              statusTextClass = 'status-text online';
              statusText = 'Online';
            } else {
              statusDot = '<span class="offline-dot"></span>';
              statusTextClass = 'status-text offline';
              const lastSeenSnap = await db.ref(`userProfiles/${otherUid}/lastSeen`).once('value');
              const lastSeen = lastSeenSnap.val();
              statusText = lastSeen ? `Last seen: ${calculateTimeAgo(lastSeen)}` : 'Last seen: unknown';
            }
            initialStatusHtml = `${statusDot}<span class="${statusTextClass}">${statusText}</span>`;
            displayText = `DM: ${otherUsername}`;

            // Attach real-time listener for this user
            const onlineRef = db.ref(`userProfiles/${otherUid}/online`);
            onlineRef.on('value', async (statusSnap) => {
              const currentIsOnline = statusSnap.val() === true;
              let newStatusHtml = '';
              let newStatusDot, newStatusTextClass, newStatusText;
              if (currentIsOnline) {
                newStatusDot = '<span class="online-dot"></span>';
                newStatusTextClass = 'status-text online';
                newStatusText = 'Online';
              } else {
                newStatusDot = '<span class="offline-dot"></span>';
                newStatusTextClass = 'status-text offline';
                const lastSeenSnap = await db.ref(`userProfiles/${otherUid}/lastSeen`).once('value');
                const lastSeen = lastSeenSnap.val();
                newStatusText = lastSeen ? `Last seen: ${calculateTimeAgo(lastSeen)}` : 'Last seen: unknown';
              }
              newStatusHtml = `${newStatusDot}<span class="${newStatusTextClass}">${newStatusText}</span>`;
              const currentDiv = document.querySelector(`[data-otherUid="${otherUid}"]`);
              if (currentDiv) {
                const statusSpan = currentDiv.querySelector('.status-span');
                if (statusSpan) {
                  statusSpan.innerHTML = newStatusHtml;
                }
              }
            });
            onlineListeners[otherUid] = onlineRef;
          } else {
            displayText = chatId;
          }
        }

        div.innerHTML = displayText;
        if (initialStatusHtml) {
          const statusSpan = document.createElement('span');
          statusSpan.className = 'status-span';
          statusSpan.innerHTML = initialStatusHtml;
          div.appendChild(statusSpan);
        }

        div.onclick = ()=>{
          currentChatId = chatId;
          unreadDMs[chatId]=0;
          updateChatListBadges();
          updateTitle();
          document.querySelectorAll('.chatItem').forEach(el=>el.classList.remove('activeChat'));
          div.classList.add('activeChat');

          // Update lastReadTimestamp on open
          const updates = {};
          updates[`/userChats/${currentUid}/${chatId}/lastReadTimestamp`] = Date.now();
          db.ref().update(updates);

          listenMessages(chatId);
          setupAllUnreadListeners(); // Re-setup for background chats
        };

        chatListDiv.appendChild(div);
      }
      setupAllUnreadListeners(); // Initial setup
    });
  }

  window.addEventListener('beforeunload', ()=>{
    if(currentChatId && currentUid){
      try{ db.ref(`typing/${currentChatId}/${currentUid}`).remove(); }catch(e){}
    }
    // Clean up listeners
    Object.keys(chatListeners).forEach(id => {
      chatListeners[id].off();
    });
    Object.keys(onlineListeners).forEach(uid => {
      if (onlineListeners[uid]) onlineListeners[uid].off();
    });
  });
});
</script>

</body>
</html>